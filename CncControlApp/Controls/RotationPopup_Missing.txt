
     private async System.Threading.Tasks.Task WaitForIdleState()
        {
    // Event-driven wait for Idle, with timeout and seenNonIdle tracking
 var controller = App.MainController;
       if (controller == null) return;

            var tcs = new System.Threading.Tasks.TaskCompletionSource<bool>(System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously);
  bool seenNonIdle = false;

    PropertyChangedEventHandler handler = (s, e) =>
    {
             try
      {
     if (e.PropertyName != nameof(controller.MachineStatus)) return;
         string state = controller.MachineStatus ?? string.Empty;

       if (state.StartsWith("Alarm", StringComparison.OrdinalIgnoreCase))
            {
                // Fail fast on alarm
    tcs.TrySetResult(false);
             return;
            }

        if (state.StartsWith("Run", StringComparison.OrdinalIgnoreCase) ||
            state.StartsWith("Jog", StringComparison.OrdinalIgnoreCase))
        {
          seenNonIdle = true;
    return;
        }

  if (state.StartsWith("Idle", StringComparison.OrdinalIgnoreCase))
   {
      // Only complete once we've observed a non-idle state to avoid instant completion
              if (seenNonIdle)
                  {
tcs.TrySetResult(true);
    }
          }
     }
                catch { }
            };

  try
            {
  controller.PropertyChanged += handler;

         // In case movement is already in progress before event subscription, do a quick initial check
      string init = controller.MachineStatus ?? string.Empty;
      if (init.StartsWith("Run", StringComparison.OrdinalIgnoreCase) || init.StartsWith("Jog", StringComparison.OrdinalIgnoreCase))
  seenNonIdle = true;

          // Fallback: if we never see a non-idle transition, but we're still Idle after a short grace period,
          // assume the rapid was instantaneous and allow redraw to proceed.
            _ = System.Threading.Tasks.Task.Run(async () =>
    {
           try
        {
           await System.Threading.Tasks.Task.Delay(1200).ConfigureAwait(false);
         if (!seenNonIdle)
              {
         string s2 = controller.MachineStatus ?? string.Empty;
      if (s2.StartsWith("Idle", StringComparison.OrdinalIgnoreCase))
            tcs.TrySetResult(true);
             }
    }
        catch { }
     });

   using (var cts = new System.Threading.CancellationTokenSource(30000))
  {
   using (cts.Token.Register(() => tcs.TrySetCanceled(), useSynchronizationContext: false))
          {
   await tcs.Task.ConfigureAwait(false);
        }
 }
            }
 catch (System.OperationCanceledException)
        {
   System.Diagnostics.Debug.WriteLine("⚠️ WaitForIdleState timed out after 30000ms");
            }
     catch (Exception ex)
 {
       System.Diagnostics.Debug.WriteLine($"❌ WaitForIdleState error: {ex.Message}");
    }
            finally
            {
      controller.PropertyChanged -= handler;
         }
        }

        #region Marker Management

 /// <summary>
        /// Update or create touch point marker on overlay canvas
        /// </summary>
    private void UpdateTouchPointMarker(Point touchPoint)
        {
            try
          {
      if (TopViewOverlayCanvas == null) return;

                // Remove existing touch marker
     if (_touchPointMarker != null)
      {
         TopViewOverlayCanvas.Children.Remove(_touchPointMarker);
   }

    // Create new touch point marker (gold target)
    _touchPointMarker = new Ellipse
{
        Width = 20,
       Height = 20,
            Stroke = new SolidColorBrush(Colors.Gold),
      StrokeThickness = 3,
            Fill = new SolidColorBrush(Color.FromArgb(100, 255, 215, 0)), // Semi-transparent gold
             IsHitTestVisible = false
      };

     Canvas.SetLeft(_touchPointMarker, touchPoint.X - 10);
         Canvas.SetTop(_touchPointMarker, touchPoint.Y - 10);
 Canvas.SetZIndex(_touchPointMarker, 1000);

       TopViewOverlayCanvas.Children.Add(_touchPointMarker);

           // Pulse animation
          var pulseAnimation = new DoubleAnimation
      {
    From = 1.0,
      To = 0.6,
    Duration = TimeSpan.FromMilliseconds(500),
        AutoReverse = true,
               RepeatBehavior = RepeatBehavior.Forever
                };
                _touchPointMarker.BeginAnimation(UIElement.OpacityProperty, pulseAnimation);

     System.Diagnostics.Debug.WriteLine($"✅ Touch point marker created at canvas ({touchPoint.X:F1},{touchPoint.Y:F1})");
            }
            catch (Exception ex)
      {
       System.Diagnostics.Debug.WriteLine($"❌ UpdateTouchPointMarker error: {ex.Message}");
    }
    }

        /// <summary>
        /// Update or create machine position marker on overlay canvas
        /// </summary>
        private void UpdateMachineMarker(Point? machinePoint)
        {
   try
     {
  if (TopViewOverlayCanvas == null) return;

  if (!machinePoint.HasValue)
     {
         // Remove marker if no valid position
         if (_machineMarker != null)
     {
      TopViewOverlayCanvas.Children.Remove(_machineMarker);
           _machineMarker = null;
           }
        return;
     }

  // Remove existing machine marker
     if (_machineMarker != null)
       {
        TopViewOverlayCanvas.Children.Remove(_machineMarker);
                }

          // Create new machine marker (lime green circle)
   _machineMarker = new Ellipse
      {
      Width = 18,
        Height = 18,
 Stroke = new SolidColorBrush(Colors.Lime),
               StrokeThickness = 3,
   Fill = new SolidColorBrush(Color.FromArgb(120, 0, 255, 0)), // Semi-transparent lime
       IsHitTestVisible = false
    };

          Canvas.SetLeft(_machineMarker, machinePoint.Value.X - 9);
         Canvas.SetTop(_machineMarker, machinePoint.Value.Y - 9);
     Canvas.SetZIndex(_machineMarker, 999);

        TopViewOverlayCanvas.Children.Add(_machineMarker);
   }
         catch (Exception ex)
  {
       System.Diagnostics.Debug.WriteLine($"❌ UpdateMachineMarker error: {ex.Message}");
      }
        }

        /// <summary>
        /// Start timer to animate machine position during movement
  /// </summary>
     private void StartMachinePositionUpdateTimer()
        {
     try
    {
       if (_machinePositionUpdateTimer == null)
   {
        _machinePositionUpdateTimer = new DispatcherTimer
        {
        Interval = TimeSpan.FromMilliseconds(50) // Update 20 times per second
          };
               _machinePositionUpdateTimer.Tick += MachinePositionUpdateTimer_Tick;
             }

           if (!_machinePositionUpdateTimer.IsEnabled)
            {
       _isAnimatingMovement = true;
     _machinePositionUpdateTimer.Start();
    System.Diagnostics.Debug.WriteLine("✅ Machine position animation started");
     }
      }
          catch (Exception ex)
         {
         System.Diagnostics.Debug.WriteLine($"❌ StartMachinePositionUpdateTimer error: {ex.Message}");
            }
        }

     /// <summary>
        /// Stop machine position animation timer
        /// </summary>
        private void StopMachinePositionUpdateTimer()
        {
 try
       {
  if (_machinePositionUpdateTimer != null && _machinePositionUpdateTimer.IsEnabled)
 {
          _machinePositionUpdateTimer.Stop();
 _isAnimatingMovement = false;
   System.Diagnostics.Debug.WriteLine("✅ Machine position animation stopped");
 }
}
      catch (Exception ex)
 {
                System.Diagnostics.Debug.WriteLine($"❌ StopMachinePositionUpdateTimer error: {ex.Message}");
         }
   }

        /// <summary>
        /// Timer tick handler - updates machine marker position during movement
        /// </summary>
        private void MachinePositionUpdateTimer_Tick(object sender, EventArgs e)
        {
   try
            {
         if (App.MainController?.MStatus == null) return;

 // Get current machine position
          double currentX = App.MainController.MStatus.X;
     double currentY = App.MainController.MStatus.Y;

         // Convert to canvas coordinates
         var canvasPoint = MachineToCanvasPoint(currentX, currentY);
      if (canvasPoint.HasValue)
        {
        // Update machine marker position
       UpdateMachineMarker(canvasPoint);

        // Check if machine reached target (within 0.5mm tolerance)
      if (_lastTouchedMachineX.HasValue && _lastTouchedMachineY.HasValue)
    {
      double distanceX = Math.Abs(currentX - _lastTouchedMachineX.Value);
      double distanceY = Math.Abs(currentY - _lastTouchedMachineY.Value);
           double totalDistance = Math.Sqrt(distanceX * distanceX + distanceY * distanceY);

        if (totalDistance < 0.5) // Within 0.5mm
    {
         // Markers have met - remove touch point marker
    System.Diagnostics.Debug.WriteLine("✅ Machine reached target - removing touch marker");

      if (_touchPointMarker != null && TopViewOverlayCanvas != null)
            {
       TopViewOverlayCanvas.Children.Remove(_touchPointMarker);
    _touchPointMarker = null;
                }

   // Reset target
        _lastTouchedMachineX = null;
 _lastTouchedMachineY = null;

            // Disable G00 button
         if (GotoTouchedCoordButton != null)
      {
GotoTouchedCoordButton.IsEnabled = false;
         }

        // Update display
 if (TouchedCoordDisplayTextBlock != null)
   {
    TouchedCoordDisplayTextBlock.Text = "Click canvas to select position";
       }
            }
        }
     }
            }
     catch (Exception ex)
            {
     System.Diagnostics.Debug.WriteLine($"❌ MachinePositionUpdateTimer_Tick error: {ex.Message}");
  }
        }

        #endregion
    }
}
